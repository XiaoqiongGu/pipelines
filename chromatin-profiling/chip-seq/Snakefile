# standard library imports
#
import os
import subprocess
import shutil

# third party imports
#
from snakemake.utils import report

# project specific imports
#
LIB_PATH = os.path.abspath(
    os.path.join(os.path.dirname(os.path.realpath(workflow.snakefile)), "..", "..", "lib"))
if LIB_PATH not in sys.path:
    sys.path.insert(0, LIB_PATH)
from pipelines import chroms_and_lens_from_fasta


RESULT_OUTDIR = 'out'


# non-login bash
shell.executable("/bin/bash")
shell.prefix("source rc/snakemake_env.rc;")

include: "../../rules/samtools.rules"
include: "../../rules/logging.rules"
include: "../../rules/report.rules"
include: "bwa_mem.rules"
include: "bwa_aln.rules"

# FIXME
localrules: final, report


CONTROL_DIR = os.path.join(RESULT_OUTDIR, 'control')
MEMECHIP_OUTDIR_SUFFIX = "memechip"# relativ to input, no "-"!

# key is taken from directory: macs2-{key}
MACS2PEAK_TO_ARG = {
    'narrow': "",
    'broad': "--broad"
}

# key is taken from directory: dfilter-{key}
DFILTERPEAK_TO_ARG = {
    'TF': "-ks=10 -lpval=6 -nonzero -refine",
    'narrow': "-ks=60 -lpval=6",
    'broad': "-ks=20 -lpval=3 â€“nonzero",
#    'openchromatin':  "-ks=50 -bs=100 -lpval=3",
}


# METHOD_PEAK_COMB define out directories. separate by dash. later
# used as /{method}-{peak} and peak is translated using the maps above
# to corresponding arguments
#
if config['peak_type']  == "TF":
    METHOD_PEAK_COMB = ["macs2-narrow"]
    #METHOD_PEAK_COMB.append("dfilter-TF")

elif config['peak_type']  == "histone-narrow":
    METHOD_PEAK_COMB = ["macs2-narrow"]
    #METHOD_PEAK_COMB.append("dfilter-narrow")

elif config['peak_type']  == "histone-broad":
    METHOD_PEAK_COMB = ["macs2-narrow", "macs2-broad"]
    #METHOD_PEAK_COMB.append("dfilter-broad")

#elif config['peak_type'] == "open-chromatin":
#    METHOD_PEAK_COMB = ["macs2-narrow", "macs2-broad"]
#    #METHOD_PEAK_COMB.append("dfilter-openchromatin")

else:
    raise ValueError(config['peak_type'])


rule final:
    input:
        report = "report.html",
        macs2_fa = expand(
            os.path.join(RESULT_OUTDIR, "{sample}/{methodpeak}/{sample}_extbp_summits.fa"),
            sample=[s for s in config['samples'] if s != 'control'],
            methodpeak=METHOD_PEAK_COMB),
        bw = expand(
            os.path.join(RESULT_OUTDIR, "{sample}/{methodpeak}/{sample}_treat_pileup.bw"),
            sample=[s for s in config['samples'] if s != 'control'],
            methodpeak=METHOD_PEAK_COMB),
        memechip_html = expand(
            os.path.join(RESULT_OUTDIR, "{sample}/{methodpeak}/{sample}-{MEMECHIP_OUTDIR_SUFFIX}", "index.html"),
            sample=[s for s in config['samples'] if s != 'control'],
            methodpeak=METHOD_PEAK_COMB,
            MEMECHIP_OUTDIR_SUFFIX=MEMECHIP_OUTDIR_SUFFIX)


        
rule unit_merge_n:
    """
    Merge bam files (by name!) for multiple units into one for the given sample
    (or copy if just one).
    """
    input:
        # switch expand and wildcards and funny things happen
        lambda wc: expand('{prefix}/unit-{unit}.{mapper}-nsrt.bam',
                          prefix = wc.prefix,
                          unit = config['samples'][wc.sample],
                          mapper = wc.mapper)
    output:
        '{prefix}/{sample}/{sample}.{mapper}-nsrt.bam'
    log:
        '{prefix}/{sample}/{sample}.{mapper}-nrst.bam.log'
    message:
        "Merging files"
    threads:
        8
    run:
        if len(input) > 1:
            shell("samtools merge -n -@ {threads} {output} {input} >& {log};")
        else:
            shell("ln {input} {output} >& {log};")

     
rule macs2:
    input:
        cbam = os.path.join(CONTROL_DIR, 'control.%s-nsrt.bam' % config['mapper']),
        tbam = os.path.join(RESULT_OUTDIR, '{sample}/{sample}.%s-nsrt.bam' % config['mapper']),
    output:
        # all suffices predefined by macs2
        tbdg = temp('{outdir}/macs2-{peak}/{sample}_treat_pileup.bdg'),
        cbdg = temp('{outdir}/macs2-{peak}/{sample}_control_lambda.bdg'),
        model = '{outdir}/macs2-{peak}/{sample}_model.r',
        peak_xls = '{outdir}/macs2-{peak}/{sample}_peaks.xls',
        # narrow:
        # narrow_peak = '{outdir}/{sample}_peaks.narrowPeak',
        # summits_bed = '{outdir}/{sample}_summits.bed'
        # broad:
        # broad_peak = '{outdir}/{sample}_peaks.broadPeak',
        # gapped_peak = '{outdir}/{sample}_peaks.gappedPeak',
        # created here even if run in broad mode
        summits_bed = '{outdir}/macs2-{peak}/{sample}_summits.bed'
    log:
        "{outdir}/macs2-{peak}/macs2.log"
    message:
        "Peak calling with macs2"
    params:
        basename = lambda wc: wc.sample,
        macs2_custom_args = config.get("macs2_custom_args", ""),
        read_type_arg = '-f BAMPE' if config['paired_end'] else '',
        peak_arg = lambda wc: MACS2PEAK_TO_ARG[wc.peak],
        gsize = config["references"]["genomesize"],
    threads:
        2
    shell:
        " macs2 callpeak --treatment {input.tbam} --control {input.cbam}"
        " --gsize {params.gsize}"
        " --bdg"# NAME+'_treat_pileup.bdg and NAME+'_control_lambda.bdg'
        " {params.read_type_arg}"
        " --keep-dup all"# we've marked dups already and want to avoid problems like https://github.com/taoliu/MACS/issues/78
        " {params.peak_arg}"
        " --outdir $(dirname {output.cbdg}) --name {params.basename}"
        " {params.macs2_custom_args} >& {log};"
        # in default mode the bed file describes the 1bp summit which
        # is $2+10 from narrowPeak. in --broad mode the bed file is
        # missing and so is $10 from the broadPeak file. so create one
        # using broadPeak
        "test -e {output.summits_bed} || awk '{{d=$3-$2; mp=$2+int(d/2); printf \"%s\\t%d\\t%d\\t%s\\t%s\\n\", $1, mp, mp+1, $4, $9}}' $(ls $(dirname {output.cbdg})/*broadPeak) > {output.summits_bed};"


rule bdg_to_bw:
    input:
        bdg = "{prefix}.bdg",
        genome = config['references']['genome'],
        genome_sizes = config['references']['genome'] + ".fai",
    output:
        bw = "{prefix}.bw",
    log:
        "{prefix}.bw.log"
    message:
        "Converting to bigwig"
    shell:
        "{{ "
        # convert bedgraph to bigwig
        # getting 'bdg is not case-sensitive sorted at line 35.  Please use "sort -k1,1 -k2,2n" with LC_COLLATE=C,  or bedSort and try again.'
        "tmp={input.bdg}.srt;"
        "LC_COLLATE=C sort -k1,1 -k2,2n {input.bdg} > $tmp;"
        "bedGraphToBigWig $tmp {input.genome_sizes} {output.bw};"
        "rm -f $tmp;"
        " }} >& {log}"


rule summits_to_fasta:
    input:
        summits_bed = '{prefix}_summits.bed',
        genome = config['references']['genome'],
        genome_sizes = config['references']['genome'] + ".fai",
    output:
        seqbed = "{prefix}_extbp_seq.bed",
        fa = "{prefix}_extbp_summits.fa",
    params:
        ext_bp_arg = "{}".format(config.get("ext_bp_arg", "250")),
    log:
        "{prefix}_extbp.log"
    message:
        "Summits to fastq"
    shell:
        "{{ "
        # the following line fails with 141 (pipefail) in its original form. not sure why, but using fifo instead of pipe works.
        # "sort -k8,8rn -k7,7rn {input.summits_bed} | head -500 | coordinateSpan_Score.pl - {params.ext_bp_arg} > {output.seqbed};"
        #"coordinateSpan_Score.pl <(sort -k8,8rn -k7,7rn {input.summits_bed} | head -500) {params.ext_bp_arg} > {output.seqbed};"
        # simply following box4 in doi:10.1038/nprot.2014.083
        # FIXME add sorting back in?
        "awk '{{c=$1; s=$2-{params.ext_bp_arg}; e=$3+{params.ext_bp_arg}; printf \"%s\\t%d\\t%d\\n\", c, s<0 ? 0 : s, e}}' {input.summits_bed} > {output.seqbed};"
        "bedtools getfasta -fi {input.genome} -bed {output.seqbed} -fo {output.fa};"
        " }} >& {log}"


#FIXME run dfilter as is
#create macs2 equivalents (e.g. summit_bed in separate step
#    summit_bed = '{outdir}/dfilter-{peak}/{sample}_summits.bed',# created by us
#    ' ln -s {output.tracks} {output.summit_bed};'
#rule dfilter:
#    input:
#        cbam = os.path.join(CONTROL_DIR, 'control.%s-nsrt.bam' % config['mapper']),
#        tbam = os.path.join(RESULT_OUTDIR, '{sample}/{sample}.%s-nsrt.bam' % config['mapper']),
#    output:
#        peaks = '{outdir}/dfilter-{peak}/{sample}.Peaks',# see -o
#        tracks = '{outdir}/dfilter-{peak}/{sample}.bed.PeaksTracks',# see -o
#        # wig files are based on input file names, which we don't know at this point
#        control_wig = '{outdir}/dfilter-{peak}/{sample}_control.wig',
#        treatment_wig = '{outdir}/dfilter-{peak}/{sample}_treatment.wig',
#        filtered_treatment_wig = '{outdir}/dfilter-{peak}/{sample}_treat_pileup.wig',
#    log:
#        "{outdir}/dfilter-{peak}/dfilter.log"
#    message:
#        "Running Dfilter"
#    params:
#        peak_arg = lambda wc: DFILTERPEAK_TO_ARG[wc.peak],
#        read_type_arg = '-pe' if config['paired_end'] else '',
#        outprefix = lambda wc: os.path.join(wc.outdir, "dfilter-" + wc.peak, wc.sample)
#    shell:
#        '{{ '
#        'od=$(dirname {params.outprefix}); test -d $od || mkdir $od;'
#        'run_dfilter.sh -d={input.tbam} -c={input.cbam} -o={params.outprefix}'
#        ' -wig -f=bam {params.peak_arg} {params.read_type_arg};'
#        # control samples always called control
#        'mv $od/control*wig {output.control_wig}_;'
#        'mv $od/filtered*wig {filtered_treatment_wig}_;'
#        # only one left
#        'mv $od/*wig {output.treatment_wig};'
#        'mv {output.control_wig}_ {output.control_wig};'
#        'mv {filtered_treatment_wig}_ {filtered_treatment_wig};'
#        'test -f comkernel && rm -f comkernel;'
#        ' }} >& {log}'
#    
#

rule memechip:
    input:
        seq = "{dirname}/{sample}_extbp_summits.fa"
    output:
        "{dirname}/{sample}-{MEMECHIP_OUTDIR_SUFFIX}/index.html"
    #params:
    log:
        "{dirname}/{sample}-{MEMECHIP_OUTDIR_SUFFIX}/meme-chip.log"
    message:
        "Running meme-chip"
    params:
        outdir = "{dirname}/{sample}-{MEMECHIP_OUTDIR_SUFFIX}"
    shell:
        # note: -oc instead of -o to help with reentrance
        # might be worthwhile playing with -time
        "meme-chip -oc {params.outdir} -dna {input.seq} >& {log}"
