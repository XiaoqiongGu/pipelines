import os
import getpass
from snakemake.utils import report
from pipelines import send_status_mail, generate_timestamp
from elmlogger import ElmLogging, ElmUnit


RESULT_OUTDIR = './out'


# FIXME to conf once downstream handling clear
MARK_SHORT_SPLITS="-M"# "-M" or ""


def getuser():
    return getpass.getuser()


def mark_dups_pipe_cmd(before="", after=""):
    """FIXME review once MARK_SHORT_SPLITS is in config

    before and after are commands added before and after samblaster
    and can be used e.g. for conversion from BAM to BAM (samblaster needs SAM)

    return command will always end in pipe
    """
    
    if config['mark_dups']:
        if before:
            cmd = "{} | ".format(before)
        else:
            cmd = ""
            
        cmd += " samblaster {MARK_SHORT_SPLITS} | "
        if after:
            cmd += " {} | ".format(after)
        return cmd
    else:
        return ""

    
# read group functions following
# http://gatkforums.broadinstitute.org/gatk/discussion/6472/read-groups
   
def gen_rg_lib_id(unit):
    if unit['library_id']:
        return unit['library_id']
    else:
        return "LIB-DUMMY"

    
def gen_rg_pu_id(unit):
    """https://www.biostars.org/p/50349/"""
    if unit['run_id'] and unit['flowcell_id'] and unit['lane_id']:
        return "{}_{}.{}".format(unit['run_id'], unit['flowcell_id'], unit['lane_id'])
    else:
        return "PU-" + unit['rg_id']

    
def fastqs_from_unit(unit):
    """FIXME:add-doc
    """
    if unit['fq2']:
        return unit['fq1'], unit['fq2']
    else:
        return unit['fq1']
        

# non-login bash
shell.executable("/bin/bash")
shell.prefix("source snakemake_env.rc;")


include: "../rules/samtools.rules"


onstart:# available as patched snakemake 3.5.5
    global elm_logger

    elm_units = []
    for unit in config['units'].values():
        # For non-bcl2fastq pipelines use the input as library_files
        library_files = [unit['fq1']]
        if 'fq2' in unit and unit['fq2'] is not None:
            library_files.append(unit['fq2'])
        eu = ElmUnit._make([unit['run_id'], unit['library_id'], unit['lane_id'], library_files, None])
        elm_units.append(eu)
            
    elm_logger = ElmLogging(workflow.snakefile,
                            config['ELM']['pipeline_name'],
                            config['ELM']['pipeline_version'],
                            getuser(),#SET_ON_EXEC
                            config['ELM']['site'],
                            generate_timestamp(),# crutch: master jid would be best, but impossible to get here
                            config['ELM']['log_path'],#SET_ON_EXEC
                            elm_units)
    elm_logger.start()
onsuccess:
    elm_logger.stop(True)
    send_status_mail(config['ELM']['pipeline_name'], True,
                     config['sample'], os.path.abspath(RESULT_OUTDIR))
onerror:
    elm_logger.stop(False)
    send_status_mail(config['ELM']['pipeline_name'], False,
                     config['sample'], os.path.abspath(RESULT_OUTDIR))

                    
rule final:
    input:
        # NOTE changes here will likely have to be reflected in the report rule as well
        os.path.join(RESULT_OUTDIR, config['sample'] + '.bwamem.fixmate.merged.srt.idxstats.txt'),
        os.path.join(RESULT_OUTDIR, config['sample'] + '.bwamem.fixmate.merged.srt.bam'),
        os.path.join(RESULT_OUTDIR, config['sample'] + '.bwamem.fixmate.merged.srt.bamstats/stats_plot.html'),
        "report.html"
    message:
        """
        Pipeline run successfully completed
        """
    # Set no output in final rule. Otherwise deletion of any input will not result in a rerun


rule report:
    input:
        # NOTE should roughly match final rule
        bam=os.path.join(RESULT_OUTDIR, config['sample'] + '.bwamem.fixmate.merged.srt.bam'),
        basic_map_stats=os.path.join(RESULT_OUTDIR, config['sample'] + '.bwamem.fixmate.merged.srt.bamstats/stats_plot.html'),
    output: html="report.html"
    run:
        report("""
        ==========================================================================================
        {config[ELM][pipeline_name]} ({config[ELM][pipeline_version]}) report for {config[sample]}
        ==========================================================================================
        
        This is a generic BWA-MEM mapping pipeline.
        
        - All results can be found in the directory called {RESULT_OUTDIR}
        - Main output is a BAM file (raw base qualities): {input.bam}
        - Basic mapping statistics can be found in {input.basic_map_stats}
        """, output.html, metadata="Research Pipeline Development Team (rpd@mailman.gis.a-star.edu.sg)", configfile="conf.yaml")
        # doc "All keywords not listed below are intepreted as paths to files that shall be embedded into the document."
        # **input just attaches all input, but None is not allowed.
        # Attaching configfile is more a crutch
        # FIXME hardcoded path to configfile
        

rule sample_merge:
    """
    Merge bam files for multiple units into one for the given sample
    (or copy if just one).

    samtools sort might need control of max thread memory to not go 
    over limit for v1.3 it's 768M. if we use 16 threads this amounts 
    to max 12.3GB (on top of whatever else is running).

    Define temporary sorting out prefix to avoid nameclashes (default
    -.XXX.bam for stdin)
    """
    input:
        expand(os.path.join(RESULT_OUTDIR, '{unit}.bwamem.fixmate.srt.bam'), unit=config["units"])
    threads:
        8
    output:
        bam=os.path.join(RESULT_OUTDIR, config['sample'] + '.bwamem.fixmate.merged.srt.bam')
    message:
        "Merging files"
    benchmark:# should have same name as rule
        'benchmark/sample_merge.txt'
    run:
        # not running mark_dups_pipe_cmd again since not read name sorted anymore
        if len(input) > 1:
            shell("samtools merge -@ {threads} {output} {input};")
        else:
            shell("ln {input} {output}")
        
    
# Expecting SE/PE input read length >70 (BWA-MEM limitation)
rule map_mdups:
    """fixmate (and samblaster) only work on name sorted files. fixmate ignores secondary 
    alignments, i.e. safe to use with bwa mem -M:
    http://sourceforge.net/p/samtools/mailman/message/30556922/
         
    Setting read groups correctly is tricky and also depends on
    downstream programs. See
    e.g. http://gatkforums.broadinstitute.org/gatk/discussion/6472/read-groups
    For example for BQSR PU takes precedence over ID. PU should contain lane

    See notes for SG10K. More threads means more memory because of sorting
    """
    input:
        reffa = config['references']['genome'],
        reffai = config['references']['genome'] + ".pac",
        fastqs = lambda wildcards: fastqs_from_unit(config["units"][wildcards.unit])
    output:
        bam=temp(os.path.join(RESULT_OUTDIR, '{unit}.bwamem.fixmate.srt.bam'))
    params:
        mark_short_splits=MARK_SHORT_SPLITS,
        bwa_mem_custom_args=config.get("bwa_mem_custom_args", ""),
        sort_mem='500M',
        rg_id=lambda wildcards: config["units"][wildcards.unit]['rg_id'],# always set
        lib_id=lambda wildcards: gen_rg_lib_id(config["units"][wildcards.unit]),
        pu_id=lambda wildcards: gen_rg_pu_id(config["units"][wildcards.unit])
    message:
        'Aligning PE reads, fixing mate information, marking duplicates (if set) and converting to BAM'
    threads:
        8
    benchmark:# should have same name as rule
        'benchmark/map_mdups.txt'
    shell:
        "bwa mem {params.mark_short_splits} -t {threads}"
        " -R '@RG\\tID:{params.rg_id}\\tPL:{config[platform]}\\tPU:{params.pu_id}\\tLB:{params.lib_id}\\tSM:{config[sample]}\\tCN:GIS'"
        " {params.bwa_mem_custom_args} {input.reffa} {input.fastqs} |"
        " samtools fixmate -O sam - - |"
        + mark_dups_pipe_cmd() +
        " samtools view -@ {threads} -bu -o - |"
        " samtools sort -@ {threads} -m {params.sort_mem} -o {output.bam} -T {output.bam}.tmp -"
